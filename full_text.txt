# Config file (CONFIG.json)
{
    "logging": {
	"version": 1,
	"disable_existing_loggers": false,
	"formatters": {
	    "standard": {
		"format": "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
	    }
	},
	"handlers": {
            "file_handler": {
		"class": "logging.handlers.RotatingFileHandler",
		"formatter": "standard",
		"filename": "LOG_FILE.log",
		"maxBytes": 1048576,
		"backupCount": 3,
		"level": "INFO"
            },
	    "console": {
		"class": "logging.StreamHandler",
		"formatter": "standard",
		"level": "WARNING",
		"stream": "ext://sys.stdout"
            }
	},
	"root": {
            "handlers": ["file_handler", "console"],
            "level": "INFO"
	}
    },
    "scope": {
	"owon": {
	    "resource_address": "USB0::0x5345::0x1235::2052231::INSTR",
	    "channels": {
		"H": 1,
		"V": 2,
		"+": 3,
		"-": 4
	    },
	    "wave": {
		"amplitude": 0.05,
		"frequency": 100,
		"nduty1": 0.2,
		"nduty2": 0.4,
		"pduty1": 0.2,
		"pduty2": 0.2,
		"voltage_scale": 0.01,
		"comment": "voltage_scale should be equal with initial voltage scale of each channel. here the value is in V unit"
	    },
	    "commands": {
		"autoset": ":AUTOSET",
		"initialise": {
		    "general": [
			":HORIZONTAL:SCALE 1.0ms",
			":HORIZONTAL:OFFSET 0",
			":ACQUIRE:MODE SAMPLE",
			":ACQUIRE:DEPMEM 1K",
			":ACQUIRE:PRECISION 8",
			":TRIGGER:SINGLE:EDGE:SOURCE CH1",
			":TRIGGER:SINGLE:EDGE:COUPLING DC"
		    ],
		    "channel": [
			":CH{}:DISP ON",
			":CH{}:SCALE 10mv",
			":CH{}:OFFSET 0V",
			":CH{}:COUPLING DC"
		    ]
		},
		"measure_params": {
		    "turn_on": ":MEAS:DISP ON",
		    "turn_off": ":MEAS:DISP OFF",
		    "source": ":MEASure:SOURce CH{}",
		    "vbase": ":MEASure:VBASE?",
		    "vmin": ":MEASure:VMIN?"
		},
		"capture": {
		    "begin": ":WAV:BEG CH{}",
		    "wave_range": ":WAVEFORM:RANGE 0,1000",
		    "fetch": ":WAV:FETC?",
		    "end": ":WAV:END"
		}
	    },
	    "queries": {
		"autoset_progress": ":AUTOSET:PROGRESS?",
		"parameters": {
		    "general": {
			"time_scale": ":HORIZONTAL:SCALE?",
			"horizontal_offset": ":HORIZONTAL:OFFSET?",
			"trigger_source": ":TRIGGER:SINGLE:EDGE:SOURCE?",
			"trigger_level": ":TRIGGER:SINGLE:EDGE:LEVEL ?",
			"acquire_mode": ":ACQUIRE:MODE?",
			"memory_depth": ":ACQUIRE:DEPMEM?",
			"memory_precision": ":ACQUIRE:PRECISION?"
		    },
		    "channel": {
			"channel_display": ":CH{}:DISP?",
			"voltage_scale": ":CH{}:SCALE?",
			"vertical_offset": ":CH{}:OFFSET?",
			"channel_coupling": ":CH{}:COUPLING?"
		    }
		}
	    }
	},
	"rigol": {
	    "resource_address": "USB0::0x1AB1::0x04B0::DS6A231100003::INSTR",
	    "channels": {
		"H": 1,
		"V": 2,
		"+": 3,
		"-": 4
	    },
	    "wave": {
		"amplitude": 0.05,
		"frequency": 100,
		"nduty1": 0.2,
		"nduty2": 0.4,
		"pduty1": 0.2,
		"pduty2": 0.2,
		"comment": "I should modify something about duties in rigol class"
	    },
	    "commands": {
		"autoset": ":AUToscale",
		"start_running": ":RUN",
		"stop_running": ":STOP",
		"channel_source": ":WAV:SOUR CHAN{}",
		"initialise": {
		    "general": [
			":TRIG:EDGE:SOUR CHAN1",
			":TRIG:EDGE:LEV 0.004",
			":TRIG:EDGE:SLOP POS",
			"TIMEBASE:HREF:MODE TPOSITION"
		    ],
		    "channel": [
			":CHANNEL{}:DISP ON",
			":CHANNEL{}:OFFSET 0",
			":CHANNEL{}:SCALE 0.02",
			":CH{}:COUPLING DC"
		    ]
		}
	    },
	    "queries": {
		"trigger_status": ":TRIG:STAT?",
		"preamble": ":WAV:PRE?",
		"acquire_data": ":WAV:DATA?"
	    }
	}	    
    },
    "optimizer": {
	"qber_threshold": 0.09,
	"pso": {
	    "learning_mode": "cumulative_learning",
	    "min_x": -5000,
	    "max_x": 5001,
	    "max_particles": 20,
	    "max_iteration": 20,
	    "weight": 0.5,
	    "c1": 1,
	    "c2": 2,
	    "qber_best_best": 0.18,
	    "voltage_best_best": [0, 0, 0, 0],
	    "initial_qber_best": 0.5,
	    "dimensions": 4
	},
	"sa": {
	    "dimensions": 4,
	    "bounds": [[-5000, 5000],[-5000, 5000],[-5000, 5000],[-5000, 5000]],
	    "n_iterations": 1000,
	    "step_size": 100,
	    "temp": 10,
	    "low": -5000,
	    "high": 5001
	},
	"dqn": {
	    "total_runs": 300,
	    "input_dims": 1,
	    "n_actions": 81,
	    "memory_size": 1000000,
	    "discrete_actions_space": true,
	    "learning_rate": 0.0005,
	    "fc1_dims": 256,
	    "fc2_dims": 256,
	    "gamma": 0.99,
	    "epsilon": 0.1,
	    "epsilon_dec": 0.996,
	    "epsilon_end": 0.001,
	    "batch_size": 64,
	    "fname": "dqn_model.h5",
	    "all_actions": {
		0: "ZZZZ",
		1: "ZZZU",
		2: "ZZZD",
		3: "ZZUZ",
		4: "ZZDZ",
                5: "ZUZZ",
		6: "ZDZZ",
		7: "UZZZ",
		8: "DZZZ",
		9: "ZZUU",
                10: "ZZDD",
		11: "ZZUD",
		12: "ZZDU",
		13: "ZUZU",
                14: "ZDZD",
		15: "ZUZD",
		16: "ZDZU",
		17: "UZZU",
                18: "DZZD",
		19: "UZZD",
		20: "DZZU",
		21: "ZUUZ",
                22: "ZDDZ",
		23: "ZUDZ",
		24: "ZDUZ",
		25: "UZUZ",
                26: "DZDZ",
		27: "UZDZ",
		28: "DZUZ",
		29: "UUZZ",
                30: "DDZZ",
		31: "UDZZ",
		32: "DUZZ",
		33: "ZUUU",
                34: "ZDDD",
		35: "ZUUD",
		36: "ZUDU",
		37: "ZDUU",
                38: "ZDDU",
		39: "ZDUD",
		40: "ZUDD",
		41: "UUUZ",
                42: "DDDZ",
		43: "UUDZ",
		44: "UDUZ",
		45: "DUUZ",
                46: "DDUZ",
		47: "DUDZ",
		48: "UDDZ",
		49: "UZUU",
                50: "DZDD",
		51: "UZUD",
		52: "UZDU",
		53: "DZUU",
                54: "DZDU",
		55: "DZUD",
		56: "UZDD",
		57: "UUZU",
                58: "DDZD",
		59: "UUZD",
		60: "UDZU",
		61: "DUZU",
                62: "DDZU",
		63: "DUZD",
		64: "UDZD",
		65: "UUUU",
                66: "DDDD",
		67: "UUUD",
		68: "UUDU",
		69: "UDUU",
                70: "DUUU",
		71: "UUDD",
		72: "DDUU",
		73: "UDUD",
                74: "DUDU",
		75: "DUUD",
		76: "UDDU",
		77: "DDDU",
		78: "DDUD",
		79: "DUDD",
		80: "UDDD"
	    }
	}
    },
    "polarimeter": {
	"thorlabs": {
	    "resource_address": "USB",
	    "mode": "SENS:CALC 5",
	    "motor_on": "INP:ROT:STAT 1",
	    "motor_speed": "INP:ROT:VEL 100",
	    "queries": {
		"wavelength": "SENS:CORR:WAV?",
		"mode": "SENS:CALC?",
		"speed": ":INP:ROT:VEL?",
		"acquire_data": "SENS:DATA:LAT?"
	    }
	}
    },
    "p_controller": {
	"ozoptics": {
	    "port": "COM4",
	    "baudrate": 115200,
	    "timeout": 1,
	    "initial_state": [1000, 1000, 1000, 1000],
	    "step_size": 150,
	    "min_voltage": -5000,
	    "max_voltage": 5000
	}
    }
}


#Optimizers.py file

import time
import logging
import numpy as np
from DeepQNetwork import *

logger = logging.getLogger(__name__)

class PSO(object):
    """
    Particle Swarm Optimization (PSO) for minimizing QBER by adjusting optical fiber voltage.
    
    The code maintains:
      - A history of positions and velocities over iterations.
      - Personal best positions and scores for each particle.
      - A global best position and score.
    
    The evaluation loop is sequential (due to hardware limitations) 
    and the velocity/position updates are vectorized.
    """
    
    def __init__(self, conf_dict, acquire_polarization_instance, polarization_controller_instance):
        self.configs = conf_dict
        self.learning_mode = self.configs['optimizer']['pso']['learning_mode']
        self.threshold = self.configs['optimizer']['qber_threshold']
        self.min_x = self.configs['optimizer']['pso']['min_x']
        self.max_x = self.configs['optimizer']['pso']['max_x']
        self.max_particles = self.configs['optimizer']['pso']['max_particles']
        self.max_iteration = self.configs['optimizer']['pso']['max_iteration']
        self.weight = self.configs['optimizer']['pso']['weight']
        self.c1 = self.configs['optimizer']['pso']['c1']
        self.c2 = self.configs['optimizer']['pso']['c2']
        self.best_global_score = self.configs['optimizer']['pso']['qber_best_best']
        self.best_global_position = self.configs['optimizer']['pso']['voltage_best_best']
        self.initial_qber_best = self.configs['optimizer']['pso']['initial_qber_best']
        self.dimensions = self.configs['optimizer']['pso']['dimensions']
        self.p_controller = polarization_controller_instance
        self.p_data_acquisition = acquire_polarization_instance
        self.position_x = np.empty((self.max_iteration, self.max_particles, self.dimensions))
        self.velocity = np.empty((self.max_iteration, self.max_particles, self.dimensions))
        self.qber_values = np.empty((self.max_iteration, self.max_particles))
        self.personal_best_positions = np.empty((self.max_particles, self.dimensions))
        self.personal_best_scores = np.empty(self.max_particles)
        
    def reset_state(self):
        self.position_x.fill(0)
        self.velocity.fill(0)
        self.qber_values.fill(0)
        self.personal_best_positions.fill(0)
        self.personal_best_scores.fill(self.initial_qber_best)
        self.best_global_score = self.configs['optimizer']['pso']['qber_best_best']
        if self.learning_mode == "independent_learning":
            self.best_global_position = self.configs['optimizer']['pso']['voltage_best_best']
        logger.debug("Resetting PSO initial state done in mode {}.".format(self.learning_mode))
    
    def run(self):
        logger.info("Start running PSO optimiser")
        self.reset_state()
        begin_time = time.perf_counter()
        self.position_x[0] = np.random.randint(self.min_x, self.max_x,
                                               (self.max_particles, self.dimensions))
        self.velocity[0] = np.random.randint(self.min_x, self.max_x,
                                             (self.max_particles, self.dimensions))
        self.personal_best_positions = self.position_x[0].copy()
        for iteration in range(self.max_iteration - 1):
            for particle_no in range(self.max_particles):
                current_position = self.position_x[iteration, particle_no, :]
                current_voltage = current_position.astype(int).tolist()
                self.p_controller.send_voltages(current_voltage)
                time.sleep(0.3)
                self.p_data_acquisition.update_data(current_voltage)
                current_qber = self.p_data_acquisition.qber
                self.qber_values[iteration, particle_no] = current_qber
                if current_qber <= self.personal_best_scores[particle_no]:
                    self.personal_best_scores[particle_no] = current_qber
                    self.personal_best_positions[particle_no] = current_position.copy()
                if current_qber <= self.best_global_score:
                    self.best_global_score = current_qber
                    self.best_global_position = current_position.copy()
                if self.best_global_score < self.threshold:
                    final_voltage = self.best_global_position.astype(int).tolist()
                    self.p_controller.send_voltages(final_voltage)
                    total_time = time.perf_counter() - begin_time
                    logger.info(f"Optimization finished at \
                    iteration {iteration} with total time: {total_time:.2f}s")
                    return
            r1 = np.random.rand(self.max_particles, self.dimensions)
            r2 = np.random.rand(self.max_particles, self.dimensions)
            new_velocity = (self.weight * self.velocity[iteration] +
                            self.c1 * r1 * (self.personal_best_positions - self.position_x[iteration]) +
                            self.c2 * r2 * (self.best_global_position - self.position_x[iteration]))
            new_position = self.position_x[iteration] + new_velocity
            new_position = np.clip(new_position, self.min_x, self.max_x)
            self.velocity[iteration + 1] = new_velocity
            self.position_x[iteration + 1] = new_position
            logger.debug(f"Current QBER in iteration {iteration}: {self.p_data_acquisition.qber}")        
        logger.debug("Optimization finished without reaching the threshold.")
        total_time = time.perf_counter() - begin_time
        logger.debug(f"Total time: {total_time:.2f}s")


class SimulatedAnnealing():
    def __init__(self, conf_dict, acquire_polarization_instance, polarization_controller_instance):
        self.configs = conf_dict
        self.threshold = self.configs['optimizer']['qber_threshold']
        self.dimensions = self.configs['optimizer']['sa']['dimensions']
        self.bounds = self.configs['optimizer']['sa']['bounds']
        self.n_iterations = self.configs['optimizer']['sa']['n_iterations']
        self.step_size = self.configs['optimizer']['sa']['step_size']
        self.temp = self.configs['optimizer']['sa']['temp']
        self.low = self.configs['optimizer']['sa']['low']
        self.high = self.configs['optimizer']['sa']['high']
        self.p_controller = polarization_controller_instance
        self.p_data_acquisition = acquire_polarization_instance
        self.best = [0,0,0,0]

    def run():
        logger.info("Start running SA optimiser")
        self.p_controller.send_voltages(self.best)
        self.p_data_acquisition.update_data(self.best)
        best_eval = self.p_data_acquisition.qber
        while best_eval > self.threshold:
            for dimension in range(self.dimensions):
                best[dimension] = np.random.randint(low= self.low, high= self.high)
            self.p_controller.send_voltages(self.best)
            time.sleep(0.2)
            self.p_data_acquisition.update_data(self.best)
            best_eval = self.p_data_acquisition.qber
        curr, curr_eval = best, best_eval
        scores = []
        for i in range(self.n_iterations):
            candidate = curr + np.random.choice([-1, -0.7, -0.5, -0.3, 0, 0.3, 0.5, 0.7, 1],
                                                size=len(self.bounds)) * self.step_size
            self.p_controller.send_voltages(candidate)
            time.sleep(0.2)
            self.p_data_acquisition.update_data(self.best)
            candidate_eval = self.p_data_acquisition.qber
            if candidate_eval < best_eval:
                best, best_eval = candidate, candidate_eval
                scores.append(best_eval)
                print('>%d QBER(%s) = %.5f' % (i, best, best_eval))
            if best_eval < self.threshold:
                break
            diff = candidate_eval - curr_eval
            t = temp / float(i + 1)
            metropolis = np.exp(-diff / t)
            if diff < 0 or np.random.rand() < metropolis:
                curr, curr_eval = candidate, candidate_eval
        return [best, best_eval, scores]



class DQN():
    def __init__(self, conf_dict, acquire_polarization_instance, polarization_controller_instance):
        self.configs = conf_dict
        self.total_runs = self.configs['optimizer']['dqn']['total_runs']
        self.episode = 0
        self.scores = []
        self.all_actions = self.configs['optimizer']['dqn']['all_actions']
        self.qber_threshold = self.configs['optimizer']['dqn']['qber_threshold']
        self.mem_size = self.configs['optimizer']['dqn']['memory_size']
        self.discrete = self.configs['optimizer']['dqn']['discrete_actions_space']
        self.input_dims = self.configs['optimizer']['dqn']['input_dims']
        self.n_actions = self.configs['optimizer']['dqn']['n_actions']
        self.learning_rate = self.configs['optimizer']['dqn']['learning_rate']
        self.fc1_dims = self.configs['optimizer']['dqn']['fc1_dims']
        self.fc2_dims = self.configs['optimizer']['dqn']['fc2_dims']
        self.gamma = self.configs['optimizer']['dqn']['gamma']
        self.epsilon = self.configs['optimizer']['dqn']['epsilon']
        self.epsilon_dec = self.configs['optimizer']['dqn']['epsilon_dec']
        self.epsilon_end = self.configs['optimizer']['dqn']['epsilon_end']
        self.batch_size = self.configs['optimizer']['dqn']['batch_size']
        self.model_file = self.configs['optimizer']['dqn']['fname']
        self.env = Environment(self.all_actions, acquire_polarization_instance,
                               polarization_controller_instance, self.qber_threshold)
        self.agent = Agent(self.learning_rate, self.gamma, self.n_actions, self.discrete,
                           self.epsilon, self.batch_size, self.input_dims, self.epsilon_dec,
                           self.epsilon_end, self.fc1_dims, self.fc2_dims, self.mem_size,
                           self.model_file)

    def run(self):
        self.env.p_data_acquisition.update_data(self.env.p_controller.current_voltages)
        observation = self.env.p_data_acquisition.qber
        done = False
        score = 0
        while not done:
            action = self.agent.choose_action(observation)
            observation_, reward, done= self.env.step(action)
            score += reward
            self.agent.remember(observation, action, reward, observation_, int(done))
            observation = observation_
            self.agent.learn()
        self.scores.append(score)
        self.episode += 1
        if self.episode % 50 == 0:
            avg_score = np.mean(scores[max(0, self.episode - 100):(self.episode + 1)])
            logging.info("Episode: {} Average Scores: {}".format(self.episode, avg_score))
            self.agent.save_model()
            
    def load_model(self):
        self.agent.load_model()
    

    
#Polarimeters.py file

import pyvisa
import serial
import logging
import numpy as np
import pandas as pd

logger = logging.getLogger(__name__)

class Thorlabs(object):
    def __init__(self, conf_dict):
        self.configs = conf_dict
        self.resource_address = self.configs['polarimeter']['thorlabs']['resource_address']
        self.mode = self.configs['polarimeter']['thorlabs']['mode']
        self.motor_on = self.configs['polarimeter']['thorlabs']['motor_on']
        self.motor_speed = self.configs['polarimeter']['thorlabs']['motor_speed']
        self.result_dict = {'Azimuth': [], 'Ellipticity': [], 'S1': [],
                          'S2': [], 'S3': [], 'QBER': [],
                          'Unix_time': [], 'Additional_data': []}
        
    def connect(self):
        rm = pyvisa.ResourceManager()
        self.device = rm.open_resource(self.resource_address)
        logger.info("polarimeter connected: {}".format(self.device.query('*IDN?')))
        self.device.write('{};:{};:{}'.format(self.mode, self.motor_on, self.motor_speed))
        print("Plarimeter Wavelength(m): {}".format(self.device.query(self.configs['polarimeter']['thorlabs']['queries']['wavelength'])))
        print("Plarimeter Mode: {}".format(self.device.query(self.configs['polarimeter']['thorlabs']['queries']['mode'])))
        print("Plarimeter Motor Speed(Hz): {}".format(self.device.query(self.configs['polarimeter']['thorlabs']['queries']['speed'])))
        
    def get_data(self):
        logger.debug("Start getting data from ThorLabs")
        data = list(map(float, self.device.query(self.configs['polarimeter']['thorlabs']['queries']['acquire_data']).split(",")))
        timestamp = data[1]
        mode = data[2]
        self.az = data[9]*180/np.pi
        self.ellip = data[10]*180/np.pi
        dop = data[11]*100
        power = data[12]*1e3
        psi = data[9];
        chi = data[10];
        self.s1 = np.cos(2*psi)*np.cos(2*chi)
        self.s2 = np.sin(2*psi)*np.cos(2*chi)
        self.s3 = np.sin(2*chi)
        self.unix_time = time.time()
        self.qber = (1 + self.s1)/2
        logger.info("Current QBER: {}".fromat(self.qber))
                
    def update_data(self, additional_data):
        self.get_data()
        data_list = [self.az, self.ellip, self.s1,
                     self.s2, self.s3, self.qber,
                     self.unix_time, additional_data]
        for key, element in zip(self.result_dict.keys(), data_list):
            self.result_dict[key].append(element)
            
    def extract_results(self, output_name):
        logger.debug("Updated data has been written successfully!")
        df = pd.DataFrame(self.result_dict)
        df.to_csv(output_name, sep= ',')


#PolarizationController.py file

import serial
import logging

logger = logging.getLogger(__name__)

class OzOptics(object):
    def __init__(self, conf_dict):
        self.configs = conf_dict
        self.start_voltage = np.array(self.configs['p_controller']['ozoptics']['initial_state'])
        self.current_voltages = np.array(self.configs['p_controller']['ozoptics']['initial_state'])
        self.step = self.configs['p_controller']['ozoptics']['step_size']
        self.port = self.configs['p_controller']['ozoptics']['port']
        self.baudrate = self.configs['p_controller']['ozoptics']['baudrate']
        self.timeout = self.configs['p_controller']['ozoptics']['timeout']
        self.min_voltage = self.configs['p_controller']['ozoptics']['min_voltage']
        self.max_voltage = self.configs['p_controller']['ozoptics']['max_voltage']

    def connect(self):
        try:
            self.device = serial.Serial(self.port, self.baudrate, timeout= self.timeout)
            logger.info("OzOptics connected successfully!")
        except:
            logger.critical("OzOptics connection failed")
            exit()

    def update_voltages(self, volts):
        self.current_voltages = volts

    def send_voltages(self, volts):
        self.update_voltages(volts)
        if self.device.isOpen():
            self.device.write(("V1,"+str(int(volts[0]))+"\r\n").encode('ascii'))
            self.device.write(("V2,"+str(int(volts[1]))+"\r\n").encode('ascii'))
            self.device.write(("V3,"+str(int(volts[2]))+"\r\n").encode('ascii'))
            self.device.write(("V4,"+str(int(volts[3]))+"\r\n").encode('ascii'))
        else:
            logger.error("Polarization Controller is not open!")
            exit()

    def reset_voltages(self):
        self.send_voltages([0, 0, 0, 0])

    def action_to_voltages(self, actions):
        new_voltages = self.current_voltages.copy()  
        mapping = {"U": self.step, "D": -self.step}
        for i, action in enumerate(actions):
            new_voltages[i] += mapping.get(action, 0)
        return new_voltages

    

    

#Oscilloscopes.py file

import pyvisa
import time
import json
import logging
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from quantiphy import Quantity
from scipy.signal import find_peaks
from scipy.signal import savgol_filter

logger = logging.getLogger(__name__)

class OWON:
    def __init__(self, conf_dict):
        self.configs = conf_dict
        self.hv_qber = None
        self.pm_qber = None
        self.qber = self.hv_qber
        self.resource = pyvisa.ResourceManager()
        self.resource_address = self.configs['scope']['owon']['resource_address']
        self.instrument = self.resource.open_resource(self.resource_address)
        self.channels_dict = self.configs['scope']['owon']['channels']
        self.channels = list(self.configs['scope']['owon']['channels'].values())
        self.wave_amplitude = self.configs['scope']['owon']['wave']['amplitude']
        self.wave_frequency = self.configs['scope']['owon']['wave']['frequency']
        self.wave_period = 1.0/self.wave_frequency
        self.pduty1 = self.configs['scope']['owon']['wave']['pduty1']
        self.pduty2 = self.configs['scope']['owon']['wave']['pduty2']
        self.nduty1 = self.configs['scope']['owon']['wave']['nduty1']
        self.nduty2 = self.configs['scope']['owon']['wave']['nduty2']
        self.v_scale = self.configs['scope']['owon']['wave']['voltage_scale']  #must be in V unit to adjust offset of channels
        self.channels_params = {1: {"vbase": None, "offset": None},
                                2: {"vbase": None, "offset": None},
                                3: {"vbase": None, "offset": None},
                                4: {"vbase": None, "offset": None}}
        self.result_dict = {"Unix_time": [], "hv_qber": [], "pm_qber": [],
                            "qber": [], "Additional_data": []}

    def send(self, command):
        self.instrument.write(str(command))

    def query(self, command):
        response = self.instrument.query(str(command)).strip()
        return response

    def auto_set_device(self):
        self.send(self.configs['scope']['owon']['commands']['autoset'])
        logger.debug("start autoset OWON device")
        print("Progress: ", self.query(
            self.configs['scope']['owon']['queries']['autoset_progress']))
        time.sleep(30)
        progress = int(self.query(
            self.configs['scope']['owon']['queries']['autoset_progress']))
        print("progress: ", progress)
        while progress < 100 :
            logger.warning("Auto setting OWON scope took longer than usual!")
            time.sleep(10)
        logger.debug("Auto set OWON is Done")

    def measure_params(self):
        logger.debug("Start measuring OWON parameters")
        self.send(
            self.configs['scope']['owon']['commands']['measure_params']['turn_on'])
        for channel in self.channels:
            source_command = self.configs['scope']['owon']['commands']['measure_params']['source']
            self.send(source_command.format(channel))
            self.channels_params[channel]['vmin'] = np.float64(
                self.query(self.configs['scope']['owon']['commands']['measure_params']['vmin']))
            self.channels_params[channel]['offset'] = self.channels_params[channel]['vmin'] / self.v_scale
        self.send(self.configs['scope']['owon']['commands']['measure_params']['turn_off'])

    def initialise(self):
        logger.debug("Start initialising OWON scope")
        for command in self.configs['scope']['owon']['commands']['initialise']['general']:
            self.send(command)
        for channel in self.channels:
            for command in self.configs['scope']['owon']['commands']['initialise']['channel']:
                self.send(command.format(channel))
        self.measure_params()

        time.sleep(10)
        logger.debug("OWON initialisation done!")

    def print_device_parameters(self):
        for general_query in self.configs['scope']['owon']['queries']['parameters']['general']:
                print(general_query, self.query(
                    self.configs['scope']['owon']['queries']['parameters']['general'][general_query]))
        for channel in self.channels:
            for channel_query in self.configs['scope']['owon']['queries']['parameters']['channel']:
                print(channel_query, self.query(
                    self.configs['scope']['owon']['queries']['parameters']['channel'][channel_query].format(channel)))

    def get_sample_rate(self, outputs):
        logger.debug("Start getting sample rate of OWON")
        # see programming manual page 58
        self.update_device_parameters()
        maxSampleRates = {'single':{'8':1E9, '12': 500E6, '14':125E6}, 
                          'dual'  :{'8':1E9, '12': 500E6, '14':125E6},
                          'quad'  :{'8':1E9, '12': 500E6, '14':125E6}}
        maxRate = maxSampleRates[outputs][self.precision_bits]
        samplingPointsPerDiv = {'1K':50, '10K':500, '100K':5E3,'1M':50E3,
                                '10M':500E3,'25M':1.25E6,'50M':2.5E6,'100M':5E6,'250M':12.5E6}
        samplePts = samplingPointsPerDiv[self.sampling_points]
        if maxRate > samplePts / self.time_base:
            self.sample_rate = samplePts / self.time_base
        else:
            self.sample_rate =  maxRate
        logger.info("OWON current sample rate: {}".format(self.sample_rate))
        return self.sample_rate
    
    def update_device_parameters(self,channel= 1):
        logger.debug("Start updating OWON parameters")
        self.time_base = Quantity(self.query(
            self.configs['scope']['owon']['queries']['parameters']['general']['time_scale'])).real
        self.horizontal_offset = float(self.query(
            self.configs['scope']['owon']['queries']['parameters']['general']['horizontal_offset']))
        self.voltage_scale = Quantity(self.query(
            self.configs['scope']['owon']['queries']['parameters']['channel']['voltage_scale'].format(channel))).real
        self.vertical_offset = float(self.query(
            self.configs['scope']['owon']['queries']['parameters']['channel']['vertical_offset'].format(channel)))
        self.precision_bits = str(self.query(
            self.configs['scope']['owon']['queries']['parameters']['general']['memory_precision']))
        self.sampling_points = str(self.query(
            self.configs['scope']['owon']['queries']['parameters']['general']['memory_depth']))
    
    def capture(self):
        logger.debug("Start Capturing data from OWON")
        self.data_dict = {}
        for channel in self.channels:
            self.send(
                self.configs['scope']['owon']['commands']['capture']['begin'].format(channel))
            self.send(
                self.configs['scope']['owon']['commands']['capture']['wave_range'])
            self.data_dict[channel] = self.instrument.query_binary_values(
                self.configs['scope']['owon']['commands']['capture']['fetch'], datatype= 'h')
        self.send(
            self.configs['scope']['owon']['commands']['capture']['end'])
        _len = len(self.data_dict[1])
        if _len == 0:
            logger.critical("OWON captured nothing!!!")
            exit()
        all_equal = all(len(self.data_dict[key]) == _len for key in self.data_dict)
        if not all_equal:
            logger.critical("Inconsistent channel data during capture!!")
        logger.debug("done! captured successfully")
            
    def calculate_voltage_and_time(self):
        logger.debug("Start Scaling data from captured data")
        self.scaled_data = {channel: [] for channel in self.channels}
        self.scaled_data['time_data'] = [i / self.sample_rate for i in range(len(self.data_dict[self.channels[0]]))]
        for channel in self.channels:
            self.scaled_data[channel] = [(float(item) / 6400 - self.channels_params[channel]['offset']) *
                                         self.voltage_scale for item in self.data_dict[channel]]

    def visualise(self, data, test_form= False):
        logger.debug("Start visualising OWON data")
        fig, ax = plt.subplots()
        ax.set(xlabel='time (S)', ylabel='voltage (V)', title='WAVEFORM')
        if not test_form:
            colours = ["-r", "-g", "-b", "-y"]
            for (channel,colour) in zip(self.channels, colours):
                ax.plot(data['time_data'], data[channel], colour, label= "CH{}".format(channel))
            ax.grid()
            plt.legend(loc="upper left")
            plt.xlim([0, data['time_data'][-1]])
            plt.show()
        else:
            ax.plot(np.arange(len(data)), data, label= "visualising test wave form")
            plt.legend(loc="upper left")
            plt.show()


    def extract_period_index_v4(self, wave_form):
        logger.debug("Start extracting period from a waveform")
        zero_buffer = 0.001
        signal_buffer = self.wave_amplitude/5
        try: 
            first_zero_index = next((i for i, point in enumerate(wave_form) if point <= zero_buffer), None)
            first_signal_index = next((i for i, point in enumerate(wave_form[first_zero_index:],
                                                               start=first_zero_index) if point >= signal_buffer), None)
            second_signal_index = first_signal_index + int(self.sample_rate*self.wave_period)
            logger.debug("Period indices extracted successfully")
            return [first_signal_index, second_signal_index]
        except TypeError:
            logger.critical("Can not extract period indices!!!")
            self.visualise(wave_form, test_form= True)
            exit()
        
    def clean_wave_form_data(self, initial_index, final_index):
        logger.debug("Start cleaning waveform")
        self.cleaned_data = {}
        for key in self.scaled_data:
            self.cleaned_data[key] = self.scaled_data[key][initial_index:final_index]
        time_shift = self.scaled_data['time_data'][initial_index]
        self.cleaned_data['time_data'] = list(np.array(self.cleaned_data['time_data']) - time_shift)
                
    def discriminator(self, cleaned_wave_form):
        logger.debug("Start recognising wave type")
        type_one_wave = False
        mid_point = int(len(cleaned_wave_form)/2)
        zero_buffer = 0.001
        if np.average(cleaned_wave_form[mid_point-5:mid_point + 5]) > zero_buffer:
            type_one_wave = True
        logger.info("Type one Wave? {}".format(str(type_one_wave)))
        return type_one_wave

    def qber_calculator(self):
        logger.debug("Start calculating qber")
        self.unix_time = time.time()
        cleaned_wave_form = self.cleaned_data[1]
        wave_size = len(cleaned_wave_form)
        wave_type_one = self.discriminator(cleaned_wave_form)
        first_index = 0
        second_index = int(wave_size * self.pduty1)
        if wave_type_one:
            third_index = int(wave_size * (self.pduty1 + self.nduty1))
            last_index = int(wave_size * (self.pduty1 + self.nduty1 + self.pduty2))
            H = np.average(self.cleaned_data[self.channels_dict['H']][first_index:second_index])
            V = np.average(self.cleaned_data[self.channels_dict['V']][first_index:second_index])
            PLUS = np.average(self.cleaned_data[self.channels_dict['+']][third_index:last_index])
            MINUS = np.average(self.cleaned_data[self.channels_dict['-']][third_index:last_index])
        else:
            third_index = int(wave_size * (self.pduty1 + self.nduty2))
            last_index = int(wave_size * (self.pduty1 + self.nduty2 + self.pduty2))
            H = np.average(self.cleaned_data[self.channels_dict['H']][third_index:last_index])
            V = np.average(self.cleaned_data[self.channels_dict['V']][third_index:last_index])
            PLUS = np.average(self.cleaned_data[self.channels_dict['+']][first_index:second_index])
            MINUS = np.average(self.cleaned_data[self.channels_dict['-']][first_index:second_index])
        self.hv_qber = V / (H + V)
        self.pm_qber = MINUS / (PLUS + MINUS)
        self.qber = (1 / np.sqrt(2)) * np.sqrt(self.hv_qber**2 + self.pm_qber**2)
        logger.debug("Current QBER is: {}".format(self.qber))

    def get_data(self):
        logger.debug("Start acquiring data")
        self.capture()
        self.calculate_voltage_and_time()
        test_wave_form = self.scaled_data[2].copy()
        i_index, f_index = self.extract_period_index_v4(test_wave_form)
        self.clean_wave_form_data(i_index, f_index)
        self.qber_calculator()


    def update_data(self, additional_data):
        logger.debug("Start updating data")
        self.get_data()
        data_list = [self.unix_time, self.hv_qber, self.pm_qber, self.qber,
                     additional_data]
        for key, element in zip(self.result_dict.keys(), data_list):
            self.result_dict[key].append(element)

    def extract_results(self, output_name):
        logger.debug("Updated data has been written successfully!")
        df = pd.DataFrame(self.result_dict)
        df.to_csv(output_name, sep= ',')


class RIGOL:
    def __init__(self, conf_dict):
        self.configs = conf_dict
        self.hv_qber = None
        self.pm_qber = None
        self.qber = self.hv_qber
        self.resource = pyvisa.ResourceManager()
        self.resource_address = self.configs['scope']['rigol']['resource_address']
        self.instrument = self.resource.open_resource(self.resource_address)
        self.channels_dict = self.configs['scope']['rigol']['channels']
        self.channels = list(self.channels_dict.values())
        self.wave_amplitude = self.configs['scope']['rigol']['wave']['amplitude']
        self.wave_frequency = self.configs['scope']['rigol']['wave']['frequency']
        self.wave_period = 1.0 / self.wave_frequency
        self.pduty1 = self.configs['scope']['rigol']['wave']['pduty1']
        self.pduty2 = self.configs['scope']['rigol']['wave']['pduty2']
        self.nduty1 = self.configs['scope']['rigol']['wave']['nduty1']
        self.nduty2 = self.configs['scope']['rigol']['wave']['nduty2']
        self.result_dict = {"Unix_time": [], "hv_qber": [], "pm_qber": [],
                            "qber": [], "Additional_data": []}

    def send(self, command):
        self.instrument.write(str(command))

    def query(self, command, strip= True):
        if strip:
            response = self.instrument.query(str(command)).strip()
        else:
            response = self.instrument.query(str(command))
        return response

    def auto_set_device(self):
        logger.debug("Start auto setting RIGOL")
        self.send(self.configs['scope']['rigol']['commands']['autoset'])
        time.sleep(5)
        logger.debug("RIGOL Auto set is done!")

    def initialise(self):
        logger.debug("Start Initialising RIGOL")
        for command in self.configs['scope']['rigol']['commands']['initialise']['general']:
            self.send(command)
        for channel in self.channels:
            for command in self.configs['scope']['rigol']['commands']['initialise']['channel']:
                self.send(command.format(channel))
        time.sleep(1)
        logger.debug("RIGOL initialise done!")

    def trigger_check(self):
        status = self.configs['scope']['rigol']['queries']['trigger_status']
        counter = 0
        while counter <= 500:
            state = self.query(status)
            if state == "STOP":
                return None
            counter += 1
            time.sleep(0.01)
        logger.critical("Something went wrong due to check trigger conditions")
        exit()

    def capture(self, attempt= 0, max_attempts= 5):
        self.scaled_data = {}
        self.send(self.configs['scope']['rigol']['commands']['stop_running'])
        self.trigger_check()
        for channel in self.channels:
            self.send(self.configs['scope']['rigol']['commands']['channel_source'].format(channel))
            preamble = self.query(self.configs['scope']['rigol']['queries']['preamble'],
                                  strip= False).split(',')
            #format_type   = int(preamble[0])
            #data_type     = int(preamble[1])
            #um_points    = int(preamble[2])
            #num_avg       = int(preamble[3])
            x_increment   = float(preamble[4])
            #x_origin      = float(preamble[5])
            x_reference   = float(preamble[6])
            y_increment   = float(preamble[7])
            y_origin      = float(preamble[8])
            y_reference   = float(preamble[9])

            self.send(self.configs['scope']['rigol']['queries']['acquire_data'])
            raw_data = self.instrument.read_raw()
            header_length = int(raw_data[1]) + 2
            raw_data = raw_data[header_length:-1]  # Remove header and terminator
            data = np.frombuffer(raw_data, dtype='B')
            voltage = (data - y_reference) * y_increment + y_origin
            self.scaled_data[channel] = voltage
            if channel == 1:
                time_axis = (np.arange(len(voltage)) - x_reference) * x_increment
                self.scaled_data['time_data'] = time_axis
        _len = len(self.scaled_data[1])
        all_equal = all(len(self.scaled_data[key]) == _len for key in self.scaled_data)
        if _len == 0 or not all_equal:
            logger.error("Something went wrong due to capturing data!")
            if attempt < max_attempts:
                logger.warning(f"Retrying capture (attempt {attempt + 1} of {max_attempts})...")
                self.send(self.configs['scope']['rigol']['commands']['start_running'])
                time.sleep(0.1)
                return self.capture(attempt=attempt + 1, max_attempts=max_attempts)
            else:
                print("Can not capture data!")
                logger.critical("Maximum capture attempts reached. Exiting capture.")
                exit()
        self.send(self.configs['scope']['rigol']['commands']['start_running'])          

    def visualise(self, data):
        fig, ax = plt.subplots()
        ax.set(xlabel='time (S)', ylabel='voltage (V)', title='WAVEFORM')
        colours = ["-r", "-g", "-b", "-y"]
        for (channel,colour) in zip(self.channels, colours):
            ax.plot(data['time_data'], data[channel],
                    colour, label= "CH{}".format(channel))
        ax.grid()
        plt.legend(loc="upper left")
        plt.xlim([0, data['time_data'][-1]])
        plt.show()

    def extract_period_index(self):
        end = np.where(self.scaled_data['time_data'] >= self.wave_period)[0]
        start_index = 0
        stop_index = end[0]
        return [start_index, stop_index]

    def smoother(self):
        self.smoothed_data = {}
        for channel in self.channels:
            self.smoothed_data[channel] = savgol_filter(self.scaled_data[channel].copy(), 15, 1)
        self.smoothed_data['time_data'] = self.scaled_data['time_data'].copy()
            
    def extract_period_index_v4(self, s_channel):
        self.smoother()
        zero_buffer = 0.0001
        signal_buffer = 0.001
        first_zero_index = next((i for i, point in enumerate(self.smoothed_data[s_channel]) if point <= zero_buffer), None)
        try:
            first_signal_index = next((i for i, point in enumerate(self.smoothed_data[s_channel][first_zero_index:],
                                                                   start=first_zero_index) if point >= signal_buffer), None)
            end_time_value = self.smoothed_data['time_data'][first_signal_index] + self.wave_period
            second_signal_index = np.where(self.smoothed_data["time_data"] >= end_time_value)[0][0]
            return [first_signal_index, second_signal_index]
        except Exception as e:
            logger.error(e)
            self.visualise(self.smoothed_data)
            logger.critical("can not extract period indices!")
            exit()

    def clean_wave_form_data(self, initial_index, final_index):
        self.cleaned_data = {}
        for key in self.scaled_data:
            self.cleaned_data[key] = self.scaled_data[key][initial_index:final_index]
        time_shift = self.scaled_data['time_data'][initial_index]
        self.cleaned_data['time_data'] = np.array(self.cleaned_data['time_data']) - time_shift

    def discriminator(self, s_channel):
        type_one_wave = False
        mid_point = int(len(self.cleaned_data[s_channel])/2)
        zero_buffer = 0.001
        if np.average(self.cleaned_data[s_channel][mid_point-5:mid_point + 5]) > zero_buffer:
            type_one_wave = True
        return type_one_wave

    def qber_calculator(self, wave_type_one):
        self.unix_time = time.time()
        hv_qber_holder = self.hv_qber
        pm_qber_holder = self.pm_qber
        epsilon = 1e-10
        first_rise_time = self.wave_period * self.pduty1
        first_fall_time = self.wave_period * self.nduty1
        second_rise_time = self.wave_period * self.pduty2
        second_fall_time = self.wave_period * self.nduty2
        first_index = 0
        second_index = np.where(self.cleaned_data["time_data"] >= first_rise_time)[0][0]
        if wave_type_one:
            third_index = np.where(self.cleaned_data['time_data'] >=
                                   (first_rise_time + first_fall_time))[0][0]
            last_index = np.where(self.cleaned_data['time_data'] >=
                                  (first_rise_time + first_fall_time + second_rise_time))[0][0]
            H = np.average(self.cleaned_data[self.channels_dict['H']][first_index:second_index])
            V = np.average(self.cleaned_data[self.channels_dict['V']][first_index:second_index])
            PLUS = np.average(self.cleaned_data[self.channels_dict['+']][third_index:last_index])
            MINUS = np.average(self.cleaned_data[self.channels_dict['-']][third_index:last_index])
        else:
            third_index = np.where(self.cleaned_data['time_data'] >=
                                   (first_rise_time + second_fall_time))[0][0]
            last_index = np.where(self.cleaned_data['time_data'] >=
                                  (first_rise_time + second_fall_time + second_rise_time))[0][0]
            H = np.average(self.cleaned_data[self.channels_dict['H']][third_index:last_index])
            V = np.average(self.cleaned_data[self.channels_dict['V']][third_index:last_index])
            PLUS = np.average(self.cleaned_data[self.channels_dict['+']][first_index:second_index])
            MINUS = np.average(self.cleaned_data[self.channels_dict['-']][first_index:second_index])
        self.hv_qber = V / (H + V + epsilon)
        self.pm_qber = MINUS / (PLUS + MINUS + epsilon)
        if self.hv_qber >1 or self.hv_qber <0:
            self.hv_qber = hv_qber_holder
        if self.pm_qber >1 or self.pm_qber <0:
            self.pm_qber = pm_qber_holder
        self.qber = (1 / np.sqrt(2)) * np.sqrt(self.hv_qber**2 + self.pm_qber**2)
        logger.debug("Current QBER: {}".format(self.qber))
        
    def get_data(self, source_channel= 1):
        self.capture()
        i_index, f_index = self.extract_period_index_v4(source_channel)
        self.clean_wave_form_data(i_index, f_index)
        type_one_wave = self.discriminator(source_channel)
        self.qber_calculator(type_one_wave)

    def update_data(self, additional_data, source_channel= 1):
        self.get_data(source_channel)
        data_list = [self.unix_time, self.hv_qber, self.pm_qber, self.qber,
                     additional_data]
        for key, element in zip(self.result_dict.keys(), data_list):
            self.result_dict[key].append(element)

    def extract_results(self, output_name):
        logger.debug("Updated data has been written successfully!")
        df = pd.DataFrame(self.result_dict)
        df.to_csv(output_name, sep= ',')


#DeepQNetwork.py file

import logging
import numpy as np
import time
from keras.layers import Dense, Activation
from keras.models import Sequential, load_model
from keras.optimizers import Adam
import tensorflow as tf
import tensorflow.keras as keras
from tensorflow.keras.optimizers import Adam

logger = logging.getLogger(__name__)

def build_dqn(lr, n_actions, input_dims, fc1_dims, fc2_dims):
    model = Sequential([
                Dense(fc1_dims, input_shape=(input_dims,)),
                Activation('relu'),
                Dense(fc2_dims),
                Activation('relu'),
                Dense(n_actions)])
    model.compile(optimizer=Adam(learning_rate=lr), loss='mse')
    return model


class Environment():
    def __init__(self, actions_space, acquire_polarization_instance,
                 polarization_controller_instance, qber_threshold):
        self.all_actions= actions_space
        self.action_indices= list(self.all_actions.keys())
        self.p_data_acquisition = acquire_polarization_instance
        self.p_controller = polarization_controller_instance
        #self.current_state= STATE
        self.terminal_condition= qber_threshold

    def translate_actions(self, action_index):
        action_string= self.all_actions[action_index]
        return list(action_string)

    def calculate_reward(self, boundry_condition):
        """
        Reward system is designed based on distance between current state and
        our expected state. I will punish agent in each step based on this
        distance and if agent finds expected state it gives a +10 points reward
        if agent tries to cross voltage treshold, it'll give a -2000 punish

        """
        
        if boundry_condition:
            logger.debug("Hit the voltage extermom")
            return (-2000, True)                             #reward and done status
        if self.p_data_acquisition.qber < self.terminal_condition:
            logger.debug("Successfull polarisation restoration")
            return (10.0, True)
        return (-2*(self.p_data_acquisition.qber - self.terminal_condition), False)

    def check_boundry_conditions(self, action):
        acts = self.translate_actions(action)
        return any(
            (volt >= self.p_controller.max_voltage and act != 'D') or
            (volt <= self.p_controller.min_voltage and act != 'U')
            for volt, act in zip(self.p_controller.current_voltages, acts)
            )

    def step(self, action):
        boundry = self.check_boundry_conditions(action)
        if boundry:
            reward, done= self.calculate_reward(boundry_condition= True)
            self.p_controller.reset_voltages()
            return (self.p_data_acquisition.qber, reward, done)
        else:
            acts = self.translate_actions(action)
            new_voltages = self.p_controller.action_to_voltages(acts)
            self.p_controller.send_voltages(new_voltages)
            time.sleep(0.3)         #response time
            self.p_data_acquisition.update_data(new_voltages)
            reward, done= self.calculate_reward(boundry_condition= False)
            return (np.array([self.p_data_acquisition.qber]), reward, done)

class ReplayBuffer(object):
    def __init__(self, max_size, input_shape, n_actions, discrete= False):
        self.mem_size = max_size
        self.mem_cntr = 0
        self.discrete = discrete
        self.state_memory = np.zeros((self.mem_size, input_shape))
        self.new_state_memory = np.zeros((self.mem_size, input_shape))
        dtype = np.int8 if self.discrete else np.float32
        self.action_memory = np.zeros((self.mem_size, n_actions), dtype=dtype)
        self.reward_memory = np.zeros(self.mem_size)
        self.terminal_memory = np.zeros(self.mem_size, dtype=np.float32)

    def store_transition(self, state, action, reward, state_, done):
        index = self.mem_cntr % self.mem_size
        self.state_memory[index] = state
        self.new_state_memory[index] = state_
        # store one hot encoding of actions, if appropriate
        if self.discrete:
            actions = np.zeros(self.action_memory.shape[1])
            actions[action] = 1.0
            self.action_memory[index] = actions
        else:
            self.action_memory[index] = action
        self.reward_memory[index] = reward
        self.terminal_memory[index] = 1 - done
        self.mem_cntr += 1

    def sample_buffer(self, batch_size):
        max_mem = min(self.mem_cntr, self.mem_size)
        batch = np.random.choice(max_mem, batch_size)

        states = self.state_memory[batch]
        actions = self.action_memory[batch]
        rewards = self.reward_memory[batch]
        states_ = self.new_state_memory[batch]
        terminal = self.terminal_memory[batch]

        return states, actions, rewards, states_, terminal

class Agent(object):
    def __init__(self, alpha, gamma, n_actions, discrete, epsilon, batch_size,
                 input_dims, epsilon_dec=0.996,  epsilon_end=0.01,
                 fc1_dims= 256, fc2_dims= 256, mem_size=1000000, fname='dqn_model.h5'):
        self.action_space = [i for i in range(n_actions)]
        self.gamma = gamma
        self.epsilon = epsilon
        self.epsilon_dec = epsilon_dec
        self.epsilon_min = epsilon_end
        self.batch_size = batch_size
        self.model_file = fname
        self.memory = ReplayBuffer(mem_size, input_dims, n_actions, discrete)
        self.q_eval = build_dqn(alpha, n_actions, input_dims, fc1_dims, fc2_dims)

    def remember(self, state, action, reward, new_state, done):
        self.memory.store_transition(state, action, reward, new_state, done)

    def choose_action(self, state):
        if isinstance(state, list):
            state = np.array(state)
        state = state[np.newaxis, :]
        rand = np.random.random()
        if rand < self.epsilon:
            action = np.random.choice(self.action_space)
        else:
            actions = self.q_eval.predict(state)
            action = np.argmax(actions)
        return action

    def learn(self):
        if self.memory.mem_cntr > self.batch_size:
            state, action, reward, new_state, done = \
                                          self.memory.sample_buffer(self.batch_size)

            action_values = np.array(self.action_space, dtype=np.int8)
            action_indices = np.dot(action, action_values)
            q_eval = self.q_eval.predict(state)
            q_next = self.q_eval.predict(new_state)
            q_target = q_eval.copy()
            batch_index = np.arange(self.batch_size, dtype=np.int32)
            q_target[batch_index, action_indices] = reward + \
                                  self.gamma*np.max(q_next, axis=1)*done
            _ = self.q_eval.fit(state, q_target, verbose=0)
            self.epsilon = self.epsilon*self.epsilon_dec if self.epsilon > \
                           self.epsilon_min else self.epsilon_min
    def save_model(self):
        self.q_eval.save(self.model_file)
        logger.debug("Model has been saved successfully in file: {}".format(self.model_file))

    def load_model(self):
        try:
            self.q_eval = load_model(self.model_file)
            logger.info("Model has been loaded successfully from file: {}".format(self.model_file))
        except:
            logger.critical("Can not load Model! try again or start a new learning journey")
            exit()


## rigol_example.py file as an example
import time
import json
import LoggingConfiguration
import logging
from Oscilloscopes import RIGOL
from PolarizationControllers import OzOptics
from Optimizers import PSO

CONFIG_FILE = "CONFIG.json"

with open (CONFIG_FILE, 'r') as j_file:
    CONFIGS = json.load(j_file)

LoggingConfiguration.configure_logging(CONFIGS["logging"])
logger = logging.getLogger("main")


def scope_configuration(brand= "RIGOL", auto_set= False, source_channel= 1):
    scope = RIGOL(CONFIGS)
    logger.debug("scope with address {} start configuring".format(scope.resource_address))
    print("Scope Address: ", scope.resource_address)
    if auto_set:
        scope.auto_set_device()
        print("auto set is done!")
    print("wait for initialisation!")
    scope.initialise()
    time.sleep(5)
    return scope


def p_controller_configuration(brand= "OzOptics"):
    p_controller = OzOptics(CONFIGS)
    p_controller.connect()
    return p_controller



controller = p_controller_configuration()
acquirer = scope_configuration()
optimizer = PSO(CONFIGS, acquirer, controller)

acquirer.capture()
acquirer.visualise(acquirer.scaled_data)

acquirer.smoother()
acquirer.visualise(acquirer.smoothed_data)

i, f = acquirer.extract_period_index_v4(s_channel= 1)
acquirer.clean_wave_form_data(i, f)
#acquirer.visualise(acquirer.cleaned_data)
type_one = acquirer.discriminator(s_channel= 1)
print("type one wave: ", type_one)
acquirer.qber_calculator(type_one)
print("hv_qber: ",acquirer.hv_qber)
print("pm_qber: ",acquirer.pm_qber)
print("qber: ",acquirer.qber)




counter = 0
logger.info("start running main programme")
while True:
    try:
        acquirer.get_data(source_channel= 1)
        #print("live pm_qber: ",acquirer.pm_qber)
        #print("live hv_qber: ",acquirer.hv_qber)
        #if acquirer.qber < 0.1:
        #    acquirer.visualise(acquirer.cleaned_data)
        #    print("type one wave: ", acquirer.discriminator(s_channel= 1))
        #    acquirer.visualise(acquirer.smoothed_data)
        print("Live QBER: ", acquirer.qber)
        if 0.12 < acquirer.qber:
            print("start running optimiser")
            time.sleep(0.3)
            optimizer.run()
        time.sleep(0.2)
        counter += 1
        if counter % 10 == 0:
            #acquirer.visualise(acquirer.cleaned_data)
            acquirer.extract_results("new_output3.csv")
    except KeyboardInterrupt:
        logger.info("the programme has been finished")


# and readme file for further considerations
# polarization_controlling

**Pure Python APIs for Real-Time Polarization Control in Optical Setups**

---

## Overview

**polarization_controlling** is a Python toolkit designed to monitor and stabilize photon polarization in optical systems. It plays an essential role in quantum cryptography and classical photonic applications by ensuring that the desired polarization state is maintained—even in the face of inherent system imperfections such as instrument errors, birefringence, and thermal fluctuations.

In many quantum cryptography protocols (e.g., the polarization-based BB84 protocol or Coherent-One-Way QKDs), the polarization states of photons are used to generate secure keys. Any deviation from the intended state introduces errors, quantified as the **Quantum Bit Error Rate (QBER)**. Our API suite helps to quickly detect these deviations via integrated measurement devices and applies corrective feedback using electrical polarization controllers.

---

## Key Features

- **Real-Time Monitoring:**  
  Continuously tracks polarization using devices like oscilloscopes and polarimeters to assess system performance and QBER.

- **Automated Correction:**  
  Once the QBER exceeds a predefined threshold, the system calculates and applies optimal voltage adjustments to the fiber via a polarization controller.

- **Advanced Optimization Algorithms:**  
  Integrated optimizers such as Particle Swarm Optimization (PSO) and Simulated Annealing (SA) reduce correction times and maintain system stability.

- **Modular and Extensible:**  
  Designed with flexibility in mind, the APIs can easily accommodate new instruments or optimization methods, making them useful beyond polarization control applications.

---

## Experimental Setup

Instead of assembling a complex array of lasers, beam splitters, and detectors, our experimental prototype leverages a simplified yet highly effective configuration:
  
- **Measurement:**  
  An **Oscilloscope** and/or a **Polarimeter** measures the dynamic polarization fluctuations in the fiber.  
- **Adjustment:**  
  An **Electrical Polarization Controller** applies precise voltage changes to “squeeze” the fiber and restore the desired polarization state.
- **Verification:**  
  The **Oscilloscope** and/or the **Polarimeter** acquires the light's polarization directly, providing essential feedback for continuous adjustment.

**How It Works:**  
The system initiates with light of a certain polarization from the transmitter(so-called Alice). At the receiver side(Bob), it is expected that the polarization remains unchanged. In practice, any drift (due to imperfect components and environmental factors and also any possible **Eavesdropping**) is detected as an increased QBER. By implementing a prepare-and-measure configuration, the code continuously monitors for errors and, if necessary, automatically adjusts the polarization controller to correct the drift. In a QKD system Both sides agree to ignore the shared key during excessive QBER values.

---

## Supported Hardware

The project has been tested with the following instruments:

- **Polarimeter:**  
  *ThorLabs PAX1000IR2*  
  ![ThorLabs PAX1000IR2](images/Thorlabs_PAX1000IR2.jpg)  


- **Polarization Controller:**  
  *OZ Optics 4-Channel EPC Polarization Controller with USB Driver*  
  ![OZ Optics EPC](images/EPCDriver04ChannelUSB.jpg)  


- **Oscilloscopes:**  
  - *OWON VDS6047 PC Oscilloscope*  
    ![OWON VDS6047](images/OWON_VDS6074.webp)  

  - *RIGOL DS 6104 Oscilloscope*  
    ![RIGOL DS 6104](images/RIGOL_ds6104.jpg)  


These instruments are interfaced and controlled via our Python APIs, allowing streamlined integration into your measurement or experimental setups.

---

## Getting Started

1. **Installation:**  
   Clone the repository and install the required Python packages:
   ```bash
   git clone https://github.com/your_username/polarization_controlling.git
   cd polarization_controlling
   pip install -r requirements.txt

---

## Usage Example
Check out the examples directory for scripts demonstrating:
-  Initialization of measurement devices.
-  Real-time QBER monitoring.
-  Feedback control using automated optimizers.

---

## Contributing
Contributions are highly welcome! Whether you’re reporting issues, suggesting improvements, or submitting pull requests, your input is invaluable. 
Please review our CONTRIBUTING.md for detailed contribution guidelines and best practices.

---

## References
 - [Optical polarization controllers for endless polarization control](https://opg.optica.org/oe/fulltext.cfm?uri=oe-22-7-8259&id=282433)    
  - [Electrical polarization control in optical fibres](https://digital-library.theiet.org/doi/abs/10.1049/el.2011.1522)  

